/* PENTEST_attacksurface.sc

   This script enumerates the web routes, their handlers and the sensitive 
   sinks methods where the attacker controlled data is reached

   Version: 0.0.1
   Ocular Version: 0.3.70
   Author: Chetan Conikee <chetan@shiftLeft.io>
   Input: Application JAR/WAR/EAR
   Output Format: JSON
   
   Usage
   -----

   $ ./ocular.sh --script PENTEST_attacksurface.sc --command help

 */

import $ivy.`io.circe::circe-core:0.10.0`
import $ivy.`io.circe::circe-generic:0.10.0`
import $ivy.`io.circe::circe-parser:0.10.0`
import $ivy.`io.circe::circe-optics:0.10.0`

// JSON utilities, cursors and decoders 
import io.circe.parser
import io.circe.generic.semiauto.deriveDecoder
import io.circe.generic.auto._
import io.circe.parser._, io.circe.syntax._
import io.circe.Json
import cats.syntax.either._
import io.circe.optics.JsonPath._

// Report title and description
val title = "[PENTEST] Attack Surface Enumerator Report"
val description = "This report contains web routes, their handlers and the sensitive sinks methods where the attacker controlled data is reached. They are denoted via an array \"surface\" containing keys \"route\", \"source\" and an array of \"sinks\""
val recommendation="The Attack Surface Enumerator script enumerates the specific web routes, their handlers and the sensitive sinks methods where the attacker controlled data reaches to. This script is most useful in pen-testing scenarios to conduct targetted attacks in reduced time"

// Script help and usage text

"""
Running the Script
------------------

    $ ./ocular.sh --script /path/to/PENTEST_attacksurface.sc \
                --command execute \
                --params jarFile=/path/to/test.jar,outFile=attacksurface.json

As seen above, the script takes two parameters:

    - jarFile : he path of the jar/war/ear java/scala artifact to analyze
    - outFile : The report output in JSON format

The JSON report generated has the following keys:

    "surface": Array of attack surfaces
      |_ "route": Web route such as "/login"
      |_ "source": handler method for the web route having attacker controlled parameters
      |_ "sinks": Array of sink methods such as FileReader, Logger, Exec etc

Sample Output
-------------

    {
        "title": <Script Title>
        "description": <Short Description>
        "surface" : [
            {
                "route": "/login"
                "source": "io.shiftleft.doGet(java.servlet.http.HttpServletRequest)"
                "sinks" : [ 
                    "java.io.FileReader.<init>:void(java.lang.String)" 
                ]
            },
        ]
    }
"""

case class Surface(route : String, source : String, sinks : List[String])
case class Result(title : String, description : String, recommendation : String, attackSurface : List[Surface])

// If the script is imported in Ocular shell, the following method can be used
// directly to print JSON on the shell via "PENTEST_attacksurface.getAttackSurface(cpg)"
def getAttackSurface(cpg: io.shiftleft.codepropertygraph.Cpg) : String = {
    val surfaceList = cpg.finding.ioFlow.primaryFlow.map { x =>
    
    Surface(x.source.method.start.definingTypeDecl.annotation.parameterAssign.value.code.l.filter(_.contains("[")).headOption.getOrElse(""),
                x.source.method.fullName,
                List(x.sink.method.fullName))}.l.filter(!_.route.equals(""))

    Result(title, description, recommendation, surfaceList).asJson.spaces2
}

def createResults(jarFile: String, dirPath: String) = {
    val as = dirPath + java.io.File.separator + "PENTEST_attacksurface.json"
    val writer = new java.io.PrintWriter(new java.io.File(as))
    writer.write(getAttackSurface(cpg))
    writer.close()
    as
}

// This method auto-executes when script is called externally with "execute"
@doc(description)
@main def execute(jarFile: String, outFile: String) : Boolean = {
    
    println("[+] Verify if CPG exists") 
    if(!workspace.baseCpgExists(jarFile)) {

        println("[+] Creating CPG and SP for " + jarFile) 
        createCpgAndSp(jarFile)

        println("[+] Verify if CPG was created successfully") 
        if(!workspace.baseCpgExists(jarFile)) {
            println("Failed to create CPG for " + jarFile)
            return false
        }
    } else {
        println("[+] Loading pre-existing CPG")
        loadCpg(jarFile)
    }

    println("[+] Check if CPG is loaded")
    if(workspace.loadedCpgs.toList.size == 0) {
        println("Failed to load CPG for " + jarFile)
        return false
    } else {

        val writer = new java.io.PrintWriter(new java.io.File(outFile))
        
        writer.write(getAttackSurface(cpg))
        writer.close()
        
        printf("[+] Saving results to %s\n", outFile)
        
        return true
    }
}

// TODO Enable this when we have multiple main support
// @main def help() : String = {
//     usage
// }
