/* PENTEST_attacksurface.sc

   This script enumerates the web routes, their handlers and the sensitive 
   sinks methods where the attacker controlled data is reached

   Version: 0.0.1
   Ocular Version: 0.3.70
   Author: Chetan Conikee <chetan@shiftLeft.io>
   Input: Application JAR/WAR/EAR
   Output Format: JSON
   
   Usage
   -----

   $ ./ocular.sh --script PENTEST_attacksurface.sc --command help

 */

import $ivy.`io.circe::circe-core:0.10.0`
import $ivy.`io.circe::circe-generic:0.10.0`
import $ivy.`io.circe::circe-parser:0.10.0`
import $ivy.`io.circe::circe-optics:0.10.0`

// JSON utilities, cursors and decoders 
import io.circe.parser
import io.circe.generic.semiauto.deriveDecoder
import io.circe.generic.auto._
import io.circe.parser._, io.circe.syntax._
import io.circe.Json
import cats.syntax.either._
import io.circe.optics.JsonPath._

// Report title and description
val title = "[PENTEST] Attack Surface Enumerator Report"
val description = "This report contains web routes, their handlers and the sensitive sinks methods where the attacker controlled data is reached. They are denoted via an array \"surface\" containing keys \"route\", \"source\" and an array of \"sinks\""

// Script help and usage text
val usage = """The Attack Surface Enumerator script enumerates the specific web routes, 
their handlers and the sensitive sinks methods where the attacker controlled data reaches 
to. This script is most useful in pen-testing scenarios and 

Running the Script
------------------

    $ ./ocular.sh --script /path/to/PENTEST_attacksurface.sc \
                --command execute \
                --params jarFile=/path/to/test.jar,outFile=attacksurface.json

As seen above, the script takes two parameters:

    - jarFile : he path of the jar/war/ear java/scala artifact to analyze
    - outFile : The report output in JSON format

The JSON report generated has the following keys:

    "surface": Array of attack surfaces
      |_ "route": Web route such as "/login"
      |_ "source": handler method for the web route having attacker controlled parameters
      |_ "sinks": Array of sink methods such as FileReader, Logger, Exec etc

Sample Output
-------------

    {
        "title": <Script Title>
        "description": <Short Description>
        "surface" : [
            {
                "route": "/login"
                "source": "io.shiftleft.doGet(java.servlet.http.HttpServletRequest)"
                "sinks" : [ 
                    "java.io.FileReader.<init>:void(java.lang.String)" 
                ]
            },
        ]
    }
"""

case class Surface(route : String, source : String, sinks : List[String])
case class AttackSurface(surface : List[Surface])

implicit val recordsDecoder = deriveDecoder[AttackSurface]

// Utility method that adds script metadata to output JSON
def addMetaDataToJson(json: String) : String = {
    val parsedJson = parser.parse(json)
    val jsonObj = parsedJson match {
       case Right(value) => value.asObject
       case Left(error) => throw error
    }
    jsonObj.map(_.+:("description", description.asJson).+:("title", title.asJson)).asJson.spaces2
}

// If the script is imported in Ocular shell, the following method can be used
// directly to print JSON on the shell via "PENTEST_attacksurface.getAttackSurface(cpg)"
def getAttackSurface(cpg: io.shiftleft.codepropertygraph.Cpg) : String = {
    val surfaceList = cpg.finding.ioFlow.primaryFlow.map { x =>
    
    Surface(x.source.method.start.definingTypeDecl.annotation.parameterAssign.value.code.l.filter(_.contains("[")).headOption.getOrElse(""),
                x.source.method.fullName,
                List(x.sink.method.fullName))}.l.filter(!_.route.equals(""))

    val attackSurface = AttackSurface(surfaceList)

    attackSurface.asJson.spaces2
}

// This method auto-executes when script is called externally with "execute"
@doc(description)
@main def execute(jarFile: String, outFile: String) : Boolean = {
    
    println("[+] Verify if CPG exists") 
    if(!workspace.baseCpgExists(jarFile)) {

        println("[+] Creating CPG and SP for " + jarFile) 
        createCpgAndSp(jarFile)

        println("[+] Verify if CPG was created successfully") 
        if(!workspace.baseCpgExists(jarFile)) {
            println("Failed to create CPG for " + jarFile)
            return false
        }
    } else {
        println("[+] Loading pre-existing CPG")
        loadCpg(jarFile)
    }

    println("[+] Check if CPG is loaded")
    if(workspace.loadedCpgs.toList.size == 0) {
        println("Failed to load CPG for " + jarFile)
        return false
    } else {

        val writer = new java.io.PrintWriter(new java.io.File(outFile))
        val report = addMetaDataToJson(getAttackSurface(cpg))

        writer.write(report)
        writer.close()
        
        printf("[+] Saving results to %s\n", outFile)
        
        return true
    }
}


// TODO Enable this when we have multiple main support
// @main def help() : String = {
//     usage
// }
